import heapq
import math
from collections import Counter, deque
from functools import cache
from itertools import product
from typing import List, Optional


# 980. 不同路径 III
# 困难
# 268
# 相关企业
# 在二维网格 grid 上，有 4 种类型的方格：
#
# 1 表示起始方格。且只有一个起始方格。
# 2 表示结束方格，且只有一个结束方格。
# 0 表示我们可以走过的空方格。
# -1 表示我们无法跨越的障碍。
# 返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。
#
# 每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。
#
#
#
# 示例 1：
#
# 输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
# 输出：2
# 解释：我们有以下两条路径：
# 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
# 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
# 示例 2：
#
# 输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
# 输出：4
# 解释：我们有以下四条路径：
# 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
# 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
# 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
# 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
# 示例 3：
#
# 输入：[[0,1],[2,0]]
# 输出：0
# 解释：
# 没有一条路能完全穿过每一个空的方格一次。
# 请注意，起始和结束方格可以位于网格中的任意位置。

class Solution:
    def uniquePathsIII(self, grid: List[List[int]]) -> int:
        s = [0, 0, 0]
        for i in range(len(grid)):
            for j in range(len(grid[0])):
                if grid[i][j] == 1:
                    s[0] = i
                    s[1] = j
                if grid[i][j] == 0:
                    s[2] += 1

        def bfs(i, j, k):
            t = grid[i][j]
            grid[i][j] = -1
            res = 0
            for l in range(0, 3, 2):
                if 0 <= i + l - 1 < len(grid):
                    if grid[i + l - 1][j] == 0:
                        res += bfs(i + l - 1, j, k - 1)
                    elif grid[i + l - 1][j] == 2:
                        if k - 1 == 0:
                            res += 1
                if 0 <= j + l - 1 < len(grid[0]):
                    if grid[i][j + l - 1] == 0:
                        res += bfs(i, j + l - 1, k - 1)
                    elif grid[i][j + l - 1] == 2:
                        if k - 1 == 0:
                            res += 1
            grid[i][j] = t
            return res

        res = bfs(s[0], s[1], s[2] + 1)

        return res



if __name__ == "__main__":
    grid = [[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
    test = Solution().uniquePathsIII(grid)
    print(test)
